<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Creating a memory object | Ziang Tian's Personal Blogs</title><meta name="author" content="Ziang Tian"><meta name="copyright" content="Ziang Tian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="We have learned the rough process of creating an object in gem5. To recap, we:  create a .py python interface for the class we wish to create declare the object in a .hh header file implement the obje">
<meta property="og:type" content="article">
<meta property="og:title" content="Creating a memory object">
<meta property="og:url" content="http://ziangtian.github.io/personal/2024/05/10/Gem5/gem5-creating-mem-object/index.html">
<meta property="og:site_name" content="Ziang Tian&#39;s Personal Blogs">
<meta property="og:description" content="We have learned the rough process of creating an object in gem5. To recap, we:  create a .py python interface for the class we wish to create declare the object in a .hh header file implement the obje">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://ziangtian.github.io/personal/img/pfp.jpg">
<meta property="article:published_time" content="2024-05-10T13:10:37.000Z">
<meta property="article:modified_time" content="2024-05-12T08:19:27.439Z">
<meta property="article:author" content="Ziang Tian">
<meta property="article:tag" content="gem5">
<meta property="article:tag" content="arch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ziangtian.github.io/personal/img/pfp.jpg"><link rel="shortcut icon" href="/personal/img/favicon.png"><link rel="canonical" href="http://ziangtian.github.io/personal/2024/05/10/Gem5/gem5-creating-mem-object/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/personal/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/personal/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Creating a memory object',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-12 16:19:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/widen.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/personal/img/pfp.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/personal/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a><a href="/personal/tags/"><div class="headline">Tags</div><div class="length-num">7</div></a><a href="/personal/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/personal/archives/"><span> 🗃️Archives</span></a></div><div class="menus_item"><a class="site-page" href="https://ziangtian.github.io"><span> 📊Academic Page</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/personal/img/ambient.jpg')"><nav id="nav"><span id="blog-info"><a href="/personal/" title="Ziang Tian's Personal Blogs"><span class="site-name">Ziang Tian's Personal Blogs</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/personal/archives/"><span> 🗃️Archives</span></a></div><div class="menus_item"><a class="site-page" href="https://ziangtian.github.io"><span> 📊Academic Page</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Creating a memory object</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2024-05-12T08:19:27.439Z" title="Updated 2024-05-12 16:19:27">2024-05-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/personal/categories/Learning/">Learning</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/personal/categories/Learning/Arch/">Arch</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/personal/categories/Learning/Arch/Gem5/">Gem5</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>We have learned the rough process of creating an object in gem5. To recap, we:</p>
<ol>
<li>create a <code>.py</code> python interface for the class we wish to create</li>
<li>declare the object in a <code>.hh</code> header file</li>
<li>implement the object in a <code>.cc</code> cpp file</li>
<li>register the object and files in a <code>SConscipt</code> python file</li>
<li>rebuild the system and import our objects</li>
</ol>
<p>However, we are yet to actually create one object and call it in our config script. In this blog, we’re gonna create a semi-functional memory object in gem5. </p>
<h2 id="Ports-and-Packets-in-Gem5"><a href="#Ports-and-Packets-in-Gem5" class="headerlink" title="Ports and Packets in Gem5"></a>Ports and Packets in Gem5</h2><p>Before we can create the smallest functional object in gem5, we need to have a working knowledge of the ports and packets in gem5.</p>
<p>All memory objects are connected together via <strong>ports</strong>. There are two types of ports in gem5: request ports and response ports. Data flows from request ports to response ports in the form of <strong>packets</strong>. We do not need to get into the details of packets for now – except that all of the port interface accept a Packet <em>pointer</em> as a parameter. It’s a type so common that gem5 defined a type for it: <code>PacketPtr</code>.</p>
<p>Both the response port and the request port have two functions predefined in <code>port.hh</code> to send and receive the their packets. For request ports, they are <code>sendTimingReq</code> and <code>recvTimingResp</code>. The former sending the request packet to the response port and the latter expecting to receive the respose packet from the reponse port. For response ports, they are <code>recvTimingReq</code> and <code>sendTimingResp</code>. As an example, this is how <code>SendTiming</code> is implemented in <code>port.hh</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">RequestPort::sendTimingReq</span><span class="params">(PacketPtr pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">addTrace</span>(pkt);</span><br><span class="line">        <span class="type">bool</span> succ = TimingRequestProtocol::<span class="built_in">sendReq</span>(_responsePort, pkt);</span><br><span class="line">        <span class="keyword">if</span> (!succ)</span><br><span class="line">            <span class="built_in">removeTrace</span>(pkt);</span><br><span class="line">        <span class="keyword">return</span> succ;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (UnboundPortException) &#123;</span><br><span class="line">        <span class="built_in">reportUnbound</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Ports-and-functions-in-our-memory-object"><a href="#Ports-and-functions-in-our-memory-object" class="headerlink" title="Ports and functions in our memory object"></a>Ports and functions in our memory object</h2><p>Essentially, the memory object we’ll be creating is very simple, because it just sits between the CPU and the memory bus, forwarding the data for them without any caching or whatsoever. The object will have two sets of ports – one set (CPUSide) inheriting from the response port and another (MemSide) inheriting from the request port. The CPUSide consists of two response ports (data and instruction), while the Memside only consists of a single request port. Up till now you might expect to get your hands on writing the object code. But not yet. In spite of this, the port structure and the send&#x2F;receive functions can be confusing for beginners (me). I have drawn out a diagram for the code we’ll be writing:</p>
<figure>
  
<iframe frameborder="0" style="width:100%;height:600px;" src="https://viewer.diagrams.net/?tags=%7B%7D&highlight=0000ff&edit=_blank&layers=1&nav=1&title=ports.drawio#R1ZjLcpswFIafxjPpoh5A3LJs3DTdZMYTJ9PJqoPRKZACIkIOdp%2B%2BwogAOTR1Fly8scUvIcSnXzoHLcgq2d9wLwtvGYV4YWh0vyBfF4bhaI78LYVDJZiuEgIe0UrSG2ET%2FQElakrdRRTyTkPBWCyirCv6LE3BFx3N45wV3Wa%2FWNx9auYFgISN78VY%2FRFREVaqa2mN%2Fh2iIKyfrGuqJvHqxkrIQ4%2ByoiWR6wVZccZEVUr2K4hLdjWX6r5v%2F6h9HRiHVJxyw0Ph3udfHsmTm231FIzV4fH2s%2BrlxYt36oVX6wc1XnGoIXC2SymU%2FWgLclWEkYBN5vllbSFnXWqhSGJ5pcsiHlf9EOAC9i1JjfMGWAKCH2QTVWsaVnVLbZoad9FMgVG3CVv4bdXOU7MevHbdgJEFxeYDnAjiRH3PD%2BFnxrh4h5c%2BDS8H83I1jMscCpeJcEUzwmXVeOaCy0K4EkjYcchs%2B1Rua1OvSOIay67HbBNDI3oPNX0wbHb%2F5qVtZMiQf%2Buj17QLDnnG0ryUSvt9OmeYZCiWDmJ5W1sQ4XzeQS5mTNPpCRfj0rzE%2B196RLaew%2F53mv%2FsMYHVszNTYjaZHzGcusmgMVNafStyXFo4I8khpWvP%2Fw0YmOxQfl%2FARIvRsjEs3XaWPfmuOxgvnJKUvO6jJEqDOxlQJ2Vm6m8Wo95DTOvhNZy%2F3PPxl%2BP20DJH9heOkG1%2FPU9rL%2B0kZE2rUSxm4A2fg%2F%2FSQmbHcgxXWy5LQVm6YPKdeUQppDhNGxOoZWn%2Fx2n2xIPLwWAaCGbopTSGuzq7nRKX7S6dGRoQH4KcjwFRkO3JSEa2IE5JZmRBR18apwTZkS34zknJdpcjZKN%2Fi77Z6NyeZUucHmLWx4nJy%2Bbw%2BFjXOoEn138B"></iframe>

<p style="text-align: center; font-size: 0.8em;"><em>Ports and Functions in Simple Memory Object</em></p>
</figure>


<p>Notice the <code>sendTimingReq/sp</code> and <code>recvTimingReq/sp</code> functions in oval. Although some of them are already defined in header files, you’ll need to override them here, or wrap them with another handler function for convenience (unironically so). This can make things a bit messy and hard to understand in the code. We’ll get to them one at a time.</p>
<h2 id="Following-the-procedure-to-create-gem5-objects"><a href="#Following-the-procedure-to-create-gem5-objects" class="headerlink" title="Following the procedure to create gem5 objects"></a>Following the procedure to create gem5 objects</h2><h3 id="Python-interface-declaration"><a href="#Python-interface-declaration" class="headerlink" title="Python interface declaration"></a>Python interface declaration</h3><p>As our simple memory object consists of 3 ports (2 CPUSide response port and 1 MemSide request port), we’ll declare them in the python interface script.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> m5.params <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> m5.SimObject <span class="keyword">import</span> SimObject</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleMemobj</span>(<span class="title class_ inherited__">SimObject</span>):</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;SimpleMemobj&quot;</span></span><br><span class="line">    cxx_header = <span class="string">&quot;learning_gem5/part2/simple_memobj.hh&quot;</span></span><br><span class="line">    cxx_class = <span class="string">&quot;gem5::SimpleMemobj&quot;</span></span><br><span class="line"></span><br><span class="line">    inst_port = ResponsePort(<span class="string">&quot;CPU side port, receives requests&quot;</span>)</span><br><span class="line">    data_port = ResponsePort(<span class="string">&quot;CPU side port, receives requests&quot;</span>)</span><br><span class="line">    mem_side = RequestPort(<span class="string">&quot;Memory side port, sends requests&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Class-header-file"><a href="#Class-header-file" class="headerlink" title="Class header file"></a>Class header file</h3><p>Our simple memory object inherits from <code>SimObject</code>, and its member objects inherit from <code>ResponsePort</code> and <code>RequestPort</code>. We therefore use a nested class that’ll look something like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LEARNING_GEM5_PART2_SIMPLE_MEMOBJ_HH__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LEARNING_GEM5_PART2_SIMPLE_MEMOBJ_HH__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> gem5&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleMemobj</span> : <span class="keyword">public</span> SimObject</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CPUSidePort</span> : <span class="keyword">public</span> ResponsePort</span><br><span class="line">    &#123; <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MemSidePort</span> : <span class="keyword">public</span> RequestPort</span><br><span class="line"> &#123; <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SimpleMemobj</span>(SimpleMemobjParams *params);</span><br><span class="line"></span><br><span class="line">    CPUSidePort inst_port;</span><br><span class="line">    CPUSidePort data_port;</span><br><span class="line">    MemSidePort mem_port;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __LEARNING_GEM5_PART2_SIMPLE_MEMOBJ_HH__</span></span></span><br></pre></td></tr></table></figure>

<p>So we’ll first set out to fill out our inner classes: <code>CPUSidePort</code> and <code>MemSidePort</code>. </p>
<h4 id="Define-a-Response-port"><a href="#Define-a-Response-port" class="headerlink" title="Define a Response port"></a>Define a Response port</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Port on the CPU-side that receives requests.</span></span><br><span class="line"><span class="comment"> * Mostly just forwards requests to the owner.</span></span><br><span class="line"><span class="comment"> * Part of a vector of ports. One for each CPU port (e.g., data, inst)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPUSidePort</span> : <span class="keyword">public</span> ResponsePort</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// The object that owns this object (SimpleMemobj)</span></span><br><span class="line">    SimpleMemobj *owner; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/// True if the port needs to send a retry req.</span></span><br><span class="line">    <span class="type">bool</span> needRetry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// If we tried to send a packet and it was blocked, store it here</span></span><br><span class="line">    PacketPtr blockedPacket;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor. Just calls the superclass constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">CPUSidePort</span>(<span class="type">const</span> std::string&amp; name, SimpleMemobj *owner) :</span><br><span class="line">        <span class="built_in">ResponsePort</span>(name, <span class="number">1</span>), <span class="built_in">owner</span>(owner), <span class="built_in">needRetry</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">blockedPacket</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Send a packet across this port. This is called by the owner and</span></span><br><span class="line"><span class="comment">     * all of the flow control is handled in this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param packet to send.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPacket</span><span class="params">(PacketPtr pkt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get a list of the non-overlapping address ranges the owner is</span></span><br><span class="line"><span class="comment">     * responsible for. All response ports must override this function</span></span><br><span class="line"><span class="comment">     * and return a populated list with at least one item.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return a list of ranges responded to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">AddrRangeList <span class="title">getAddrRanges</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Send a retry to the peer port only if it is needed. This is called</span></span><br><span class="line"><span class="comment">     * from the SimpleMemobj whenever it is unblocked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trySendRetry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">Tick <span class="title">recvAtomic</span><span class="params">(PacketPtr pkt)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">panic</span>(<span class="string">&quot;recvAtomic unimpl.&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvFunctional</span><span class="params">(PacketPtr pkt)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Receive a timing request from the request port.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param the packet that the requestor sent</span></span><br><span class="line"><span class="comment">     * @return whether this object can consume the packet. If false, we</span></span><br><span class="line"><span class="comment">     *         will call sendRetry() when we can try to receive this</span></span><br><span class="line"><span class="comment">     *         request again.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recvTimingReq</span><span class="params">(PacketPtr pkt)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the request port if sendTimingResp was called on this</span></span><br><span class="line"><span class="comment">     * response port (causing recvTimingResp to be called on the request</span></span><br><span class="line"><span class="comment">     * port) and was unsuccesful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvRespRetry</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We have 5 functions to override, some of which are out of structural needs. We also have two important functions to implement: <code>sendPacket()</code> and <code>trySendRetry()</code>. These two along with <code>recvTimingReq()</code> and <code>recvRespRetry()</code> are the most important functions used by the CPUSide ports. The table below shows some details into it:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Note</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td><code>void sendPacket(PacketPtr pkt);</code></td>
<td>Send a packet across this port. This is called by the owner and all of the flow control is handled in this function.</td>
<td>calls <code>sendTimingResp</code> and stores the Packet if cannot send at the moment</td>
</tr>
<tr>
<td><code>void trySendRetry();</code></td>
<td>Send a retry to the peer port only if it is needed. This is called from the SimpleMemobj whenever it is unblocked.</td>
<td>calls <code>sendRetryReq</code> after making sure port is free</td>
</tr>
<tr>
<td><code>bool recvTimingReq(PacketPtr pkt) override;</code></td>
<td>Receive a timing request from the request port.</td>
<td>calls <code>handleRequest</code> by the owner</td>
</tr>
<tr>
<td><code>void recvRespRetry() override;</code></td>
<td>Called by the request port if sendTimingResp was called on this response port (causing recvTimingResp to be called on the request port) and was unsuccesful.</td>
<td>calls <code>sendPacket</code>. might fail again</td>
</tr>
</tbody></table>
<p>Note that <code>sendTimingResp()</code> (line 1 col 3) and <code>sendRetryReq()</code> (line 2 col 3) are used out of the box. you can find their declaration in <code>port.hh</code>. Apart from these 4 functions, we should also implement a <code>sendPacket()</code> for CPUSidePort and a <code>handleRequest()</code> for the memory object.</p>
<h4 id="Define-a-Request-port"><a href="#Define-a-Request-port" class="headerlink" title="Define a Request port"></a>Define a Request port</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Port on the memory-side that receives responses.</span></span><br><span class="line"><span class="comment"> * Mostly just forwards requests to the owner</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemSidePort</span> : <span class="keyword">public</span> RequestPort</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// The object that owns this object (SimpleMemobj)</span></span><br><span class="line">    SimpleMemobj *owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// If we tried to send a packet and it was blocked, store it here</span></span><br><span class="line">    PacketPtr blockedPacket;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor. Just calls the superclass constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">MemSidePort</span>(<span class="type">const</span> std::string&amp; name, SimpleMemobj *owner) :</span><br><span class="line">        <span class="built_in">RequestPort</span>(name, <span class="number">1</span>), <span class="built_in">owner</span>(owner), <span class="built_in">blockedPacket</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Send a packet across this port. This is called by the owner and</span></span><br><span class="line"><span class="comment">     * all of the flow control is handled in this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param packet to send.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPacket</span><span class="params">(PacketPtr pkt)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Receive a timing response from the response port.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recvTimingResp</span><span class="params">(PacketPtr pkt)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the response port if sendTimingReq was called on this</span></span><br><span class="line"><span class="comment">     * request port (causing recvTimingReq to be called on the responder</span></span><br><span class="line"><span class="comment">     * port) and was unsuccesful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvReqRetry</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called to receive an address range change from the peer responder</span></span><br><span class="line"><span class="comment">     * port. The default implementation ignores the change and does</span></span><br><span class="line"><span class="comment">     * nothing. Override this function in a derived class if the owner</span></span><br><span class="line"><span class="comment">     * needs to be aware of the address ranges, e.g. in an</span></span><br><span class="line"><span class="comment">     * interconnect component like a bus.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvRangeChange</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Similarly we have some particular functions to pay attention to:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Note</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td><code>void sendPacket(PacketPtr pkt);</code></td>
<td>Send a packet across this port. This is called by the owner and all of the flow control is hanled in this function.</td>
<td>calls <code>sendTimingResp</code> and stores the Packet if cannot send at the moment</td>
</tr>
<tr>
<td><code>bool recvTimingResp(PacketPtr pkt) override;</code></td>
<td>Receive a timing response from the response port.</td>
<td>calls <code>handleResponse</code> by the owner</td>
</tr>
<tr>
<td><code>void recvReqRetry() override;</code></td>
<td>Called by the response port if sendTimingReq was called on this request port (causing recvTimingReq to be called on the responder port) and was unsuccesful.</td>
<td>calls <code>sendPacket</code>. might fail again</td>
</tr>
<tr>
<td><code>void recvRangeChange() override;</code></td>
<td>Called to receive an address range change from the peer responder port. The default implementation ignores the change and does nothing. Override this function in a derived class if the owner needs to be aware of the address ranges, e.g. in an interconnect component like a bus.</td>
<td>calls <code>sendRangeChange</code> by the owner</td>
</tr>
</tbody></table>
<p>Apart from these 4 functions, we should also implement a <code>sendPacket()</code> for the MemSidePort and <code>handleResponse()</code> &amp; <code>sendRangeChange()</code> for our memory object.</p>
<h4 id="Define-the-memory-object"><a href="#Define-the-memory-object" class="headerlink" title="Define the memory object"></a>Define the memory object</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LEARNING_GEM5_PART2_SIMPLE_MEMOBJ_HH__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LEARNING_GEM5_PART2_SIMPLE_MEMOBJ_HH__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> gem5&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleMemobj</span> : <span class="keyword">public</span> SimObject</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CPUSidePort</span> : <span class="keyword">public</span> ResponsePort &#123; &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MemSidePort</span> : <span class="keyword">public</span> RequestPort &#123; &#125;</span><br><span class="line"></span><br><span class="line">    CPUSidePort instPort;</span><br><span class="line">    CPUSidePort dataPort;</span><br><span class="line">    MemSidePort memPort;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">handleRequest</span><span class="params">(PacketPtr pkt)</span></span>; <span class="comment">// handle request sent to the CPU Side</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">handleResponse</span><span class="params">(PacketPtr pkt)</span></span>; <span class="comment">// handle response from the memory side</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleFunctional</span><span class="params">(PacketPtr pkt)</span></span>; <span class="comment">// take care of functional part</span></span><br><span class="line">    <span class="function">AddrRangeList <span class="title">getAddrRanges</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendRangeChange</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">bool</span> blocked;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SimpleMemobj</span>(SimpleMemobjParams *params);</span><br><span class="line">    <span class="function">Port &amp;<span class="title">getPort</span><span class="params">(<span class="type">const</span> std::string &amp;if_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                  PortID idx=InvalidPortID)</span> <span class="keyword">override</span></span>; <span class="comment">// Get a port with a given name and index</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __LEARNING_GEM5_PART2_SIMPLE_MEMOBJ_HH__</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Class-implementation"><a href="#Class-implementation" class="headerlink" title="Class implementation"></a>Class implementation</h3><h4 id="Implementing-CPUSide-and-MemSide-ports"><a href="#Implementing-CPUSide-and-MemSide-ports" class="headerlink" title="Implementing CPUSide and MemSide ports"></a>Implementing CPUSide and MemSide ports</h4><blockquote>
<p>This part is directly taken from <a target="_blank" rel="noopener" href="https://www.gem5.org/documentation/learning_gem5/part2/memoryobject/">the tutorial</a>.</p>
</blockquote>
<p>The implementation of both the request and response port is relatively simple. For the most part, each of the port functions just forwards the information to the main memory object (SimpleMemobj).</p>
<p>Starting with two simple functions, getAddrRanges and recvFunctional simply call into the SimpleMemobj.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AddrRangeList</span><br><span class="line">SimpleMemobj::CPUSidePort::<span class="built_in">getAddrRanges</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> owner-&gt;<span class="built_in">getAddrRanges</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">SimpleMemobj::CPUSidePort::<span class="built_in">recvFunctional</span>(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> owner-&gt;<span class="built_in">handleFunctional</span>(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The implementation of these functions in the SimpleMemobj are equally simple. These implementations just pass through the request to the memory side. We can use DPRINTF calls here to track what is happening for debug purposes as well.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">SimpleMemobj::handleFunctional</span><span class="params">(PacketPtr pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memPort.<span class="built_in">sendFunctional</span>(pkt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AddrRangeList</span></span><br><span class="line"><span class="function"><span class="title">SimpleMemobj::getAddrRanges</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DPRINTF</span>(SimpleMemobj, <span class="string">&quot;Sending new ranges\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> memPort.<span class="built_in">getAddrRanges</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Similarly for the MemSidePort, we need to implement recvRangeChange and forward the request through the SimpleMemobj to the slave port.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">SimpleMemobj::MemSidePort::<span class="built_in">recvRangeChange</span>()</span><br><span class="line">&#123;</span><br><span class="line">    owner-&gt;<span class="built_in">sendRangeChange</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">SimpleMemobj::sendRangeChange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    instPort.<span class="built_in">sendRangeChange</span>();</span><br><span class="line">    dataPort.<span class="built_in">sendRangeChange</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="When-CPU-Side-receives-requests"><a href="#When-CPU-Side-receives-requests" class="headerlink" title="When CPU Side receives requests"></a>When CPU Side receives requests</h4><p>Only the response ports receive requests. And in this case the CPU side ports. When the CPUSidePort receives a request, it should first check if the memory object can accept the request.  </p>
<ul>
<li>If the object can’t at that moment, it should wait and notify the CPU to retry some time later.</li>
<li>If the object can, then our simple memory object will take the request from the CPU side and sends it from the memory side.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPUSide port</span></span><br><span class="line"><span class="type">bool</span></span><br><span class="line">SimpleMemobj::CPUSidePort::<span class="built_in">recvTimingReq</span>(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!owner-&gt;<span class="built_in">handleRequest</span>(pkt)) &#123;</span><br><span class="line">        needRetry = <span class="literal">true</span>; <span class="comment">// will be used by sendRetry func</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// memory object</span></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">SimpleMemobj::handleRequest</span><span class="params">(PacketPtr pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DPRINTF</span>(SimpleMemobj, <span class="string">&quot;Got request for addr %#x\n&quot;</span>, pkt-&gt;<span class="built_in">getAddr</span>());</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">    memPort.<span class="built_in">sendPacket</span>(pkt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the request from the CPU cannot be fulfilled, the memory object needs to let the CPU know that it should retry. Hence we define a <code>trySendRery</code> for the CPU Side:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">SimpleMemobj::CPUSidePort::<span class="built_in">trySendRetry</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (needRetry &amp;&amp; blockedPacket == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        needRetry = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">DPRINTF</span>(SimpleMemobj, <span class="string">&quot;Sending retry req for %d\n&quot;</span>, id);</span><br><span class="line">        <span class="built_in">sendRetryReq</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that the function <code>sendRetryReq</code> is used out of the box. Now we implement the logic for MemSide port to send the packet. For memory side port, it maintains a <code>blockedPacket</code>, which, if is not none, indicates that there is one packet waiting to be sent. Only when the <code>blockedPacket</code> is none can we try to send the packet using <code>sendTimingReq()</code>. if this fails, we then store this packet in <code>blockedPacket</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">SimpleMemobj::MemSidePort::<span class="built_in">sendPacket</span>(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">panic_if</span>(blockedPacket != <span class="literal">nullptr</span>, <span class="string">&quot;Should never try to send if blocked!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">sendTimingReq</span>(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For various reasons the packet might fail to be sent. We need to override the original retry function to implement the retrying system.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">SimpleMemobj::MemSidePort::<span class="built_in">recvReqRetry</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(blockedPacket != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendPacket</span>(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="When-Mem-side-receives-responses"><a href="#When-Mem-side-receives-responses" class="headerlink" title="When Mem side receives responses"></a>When Mem side receives responses</h4><p>When the memory side port receives a response, the memory object should directly give it to the CPUSide port.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line">SimpleMemobj::MemSidePort::<span class="built_in">recvTimingResp</span>(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> owner-&gt;<span class="built_in">handleResponse</span>(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the SimpleMemobj, first, it should always be blocked when we receive a response since the object is blocking. Before sending the packet back to the CPU side, we need to mark that the object no longer blocked. This must be done before calling sendTimingResp. Otherwise, it is possible to get stuck in an infinite loop as it is possible that the master port has a single callchain between receiving a response and sending another request.</p>
<p>After unblocking the SimpleMemobj, we check to see if the packet is an instruction or data packet and send it back across the appropriate port. Finally, since the object is now unblocked, we may need to notify the CPU side ports that they can now retry their requests that failed.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">SimpleMemobj::handleResponse</span><span class="params">(PacketPtr pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(blocked);</span><br><span class="line">    <span class="built_in">DPRINTF</span>(SimpleMemobj, <span class="string">&quot;Got response for addr %#x\n&quot;</span>, pkt-&gt;<span class="built_in">getAddr</span>());</span><br><span class="line"></span><br><span class="line">    blocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simply forward to the memory port</span></span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;req-&gt;<span class="built_in">isInstFetch</span>()) &#123;</span><br><span class="line">        instPort.<span class="built_in">sendPacket</span>(pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dataPort.<span class="built_in">sendPacket</span>(pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instPort.<span class="built_in">trySendRetry</span>();</span><br><span class="line">    dataPort.<span class="built_in">trySendRetry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Similar to how we implemented a convenience function for sending packets in the MemSidePort, we can implement a sendPacket function in the CPUSidePort to send the responses to the CPU side. This function calls sendTimingResp which will in turn call recvTimingResp on the peer master port. If this call fails and the peer port is currently blocked, then we store the packet to be sent later.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">SimpleMemobj::CPUSidePort::<span class="built_in">sendPacket</span>(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">panic_if</span>(blockedPacket != <span class="literal">nullptr</span>, <span class="string">&quot;Should never try to send if blocked!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">sendTimingResp</span>(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Similarly this packet might fail to be sent for various reasons. therefore we need to implement a retry system to let our memory object resend.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">SimpleMemobj::CPUSidePort::<span class="built_in">recvRespRetry</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(blockedPacket != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendPacket</span>(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SConscript"><a href="#SConscript" class="headerlink" title="SConscript"></a>SConscript</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Import(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">SimObject(<span class="string">&#x27;SimpleMemobj.py&#x27;</span>, sim_objects = [<span class="string">&quot;SimpleMemobj&quot;</span>])</span><br><span class="line">Source(<span class="string">&#x27;simple_memobj.cc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DebugFlag(<span class="string">&#x27;SimpleMemobj&#x27;</span>, <span class="string">&quot;For Learning gem5 Part 2.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Trying-out-objects-in-config-files"><a href="#Trying-out-objects-in-config-files" class="headerlink" title="Trying out objects in config files"></a>Trying out objects in config files</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m5</span><br><span class="line"><span class="keyword">from</span> m5.objects <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">system = System()</span><br><span class="line">system.clk_domain = SrcClockDomain()</span><br><span class="line">system.clk_domain.clock = <span class="string">&#x27;1GHz&#x27;</span></span><br><span class="line">system.clk_domain.voltage_domain = VoltageDomain()</span><br><span class="line">system.mem_mode = <span class="string">&#x27;timing&#x27;</span></span><br><span class="line">system.mem_ranges = [AddrRange(<span class="string">&#x27;512MB&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">system.cpu = X86TimingSimpleCPU()</span><br><span class="line"></span><br><span class="line">system.memobj = SimpleMemobj()</span><br><span class="line"></span><br><span class="line">system.cpu.icache_port = system.memobj.inst_port</span><br><span class="line">system.cpu.dcache_port = system.memobj.data_port</span><br><span class="line"></span><br><span class="line">system.membus = SystemXBar()</span><br><span class="line"></span><br><span class="line">system.memobj.mem_side = system.membus.cpu_side_ports</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system.cpu.createInterruptController()</span><br><span class="line">system.cpu.interrupts[<span class="number">0</span>].pio = system.membus.mem_side_ports</span><br><span class="line">system.cpu.interrupts[<span class="number">0</span>].int_requestor = system.membus.cpu_side_ports</span><br><span class="line">system.cpu.interrupts[<span class="number">0</span>].int_responder = system.membus.mem_side_ports</span><br><span class="line"></span><br><span class="line">system.mem_ctrl = MemCtrl()</span><br><span class="line">system.mem_ctrl.dram = DDR3_1600_8x8()</span><br><span class="line">system.mem_ctrl.dram.<span class="built_in">range</span> = system.mem_ranges[<span class="number">0</span>]</span><br><span class="line">system.mem_ctrl.port = system.membus.mem_side_ports</span><br><span class="line"></span><br><span class="line">system.system_port = system.membus.cpu_side_ports</span><br><span class="line"></span><br><span class="line">process = Process()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Adding process&quot;</span>)</span><br><span class="line"><span class="comment"># binary = &#x27;tests/test-progs/hello/bin/x86/linux/hello&#x27;</span></span><br><span class="line">binary = <span class="string">&#x27;tests/test-progs/sieve/bin/sieve64-static&#x27;</span></span><br><span class="line"><span class="comment"># for gem5 V21 and beyond</span></span><br><span class="line">system.workload = SEWorkload.init_compatible(binary)</span><br><span class="line"></span><br><span class="line">process = Process()</span><br><span class="line">process.cmd = [binary]</span><br><span class="line">system.cpu.workload = process</span><br><span class="line">system.cpu.createThreads()</span><br><span class="line"></span><br><span class="line">root = Root(full_system = <span class="literal">False</span>, system = system)</span><br><span class="line">m5.instantiate()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Beginning simulation!&quot;</span>)</span><br><span class="line">exit_event = m5.simulate()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Exiting @ tick %i because %s&#x27;</span> % (m5.curTick(), exit_event.getCause()))</span><br></pre></td></tr></table></figure>

<p>All of the above can be summarized by this image.</p>
<p><img src="https://www.gem5.org/_pages/static/figures/memobj_api.png"></p>
<hr>
<p>This is also a lot for me to process. Let’s get some indie rock.</p>
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/playlist/73oxj4NW0tddhr1TJ2hp7Z?utm_source=generator" width="100%" height="352" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/personal/tags/gem5/">gem5</a><a class="post-meta__tags" href="/personal/tags/arch/">arch</a></div><div class="post_share"><div class="social-share" data-image="/personal/img/pfp.jpg" data-sites="twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/personal/2024/05/11/Albums/808HB/" title="808s and Heartbreak"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">808s and Heartbreak</div></div></a></div><div class="next-post pull-right"><a href="/personal/2024/05/10/Gem5/gem5-objects/" title="Procedure of creating a Gem5 object"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Procedure of creating a Gem5 object</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/personal/2024/05/10/Gem5/gem5-objects/" title="Procedure of creating a Gem5 object"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-10</div><div class="title">Procedure of creating a Gem5 object</div></div></a></div><div><a href="/personal/2024/05/05/Gem5/gem5-basics/" title="Gem5 Basics"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-05</div><div class="title">Gem5 Basics</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ports-and-Packets-in-Gem5"><span class="toc-number">1.</span> <span class="toc-text">Ports and Packets in Gem5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ports-and-functions-in-our-memory-object"><span class="toc-number">2.</span> <span class="toc-text">Ports and functions in our memory object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Following-the-procedure-to-create-gem5-objects"><span class="toc-number">3.</span> <span class="toc-text">Following the procedure to create gem5 objects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-interface-declaration"><span class="toc-number">3.1.</span> <span class="toc-text">Python interface declaration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-header-file"><span class="toc-number">3.2.</span> <span class="toc-text">Class header file</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Define-a-Response-port"><span class="toc-number">3.2.1.</span> <span class="toc-text">Define a Response port</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Define-a-Request-port"><span class="toc-number">3.2.2.</span> <span class="toc-text">Define a Request port</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Define-the-memory-object"><span class="toc-number">3.2.3.</span> <span class="toc-text">Define the memory object</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-implementation"><span class="toc-number">3.3.</span> <span class="toc-text">Class implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Implementing-CPUSide-and-MemSide-ports"><span class="toc-number">3.3.1.</span> <span class="toc-text">Implementing CPUSide and MemSide ports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#When-CPU-Side-receives-requests"><span class="toc-number">3.3.2.</span> <span class="toc-text">When CPU Side receives requests</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#When-Mem-side-receives-responses"><span class="toc-number">3.3.3.</span> <span class="toc-text">When Mem side receives responses</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SConscript"><span class="toc-number">3.4.</span> <span class="toc-text">SConscript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trying-out-objects-in-config-files"><span class="toc-number">3.5.</span> <span class="toc-text">Trying out objects in config files</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(0,0,0,0)"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/personal/js/utils.js?v=4.13.0"></script><script src="/personal/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>